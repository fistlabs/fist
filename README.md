fist [![Build Status](https://travis-ci.org/fistlabs/fist.png?branch=master)](https://travis-ci.org/fistlabs/fist)
=========

```Fist``` - это nodejs-фреймворк для написания серверных приложений. ```Fist``` предлагает архитектуру, поддержка которой одинаково проста как для простых так и для сложных web-серверов.
```js

var Fist = require('fist/Framework');
var fist = new Fist();

fist.unit({
    path: 'time.appstart', 
    data: new Date()
});

fist.unit({
    path: 'time.uptime',
    deps: ['time.appstart'],
    data: function (track, ctx) {

        return new Date() - ctx.res.time.appstart
    }
});

fist.unit({
    path: 'index', 
    deps: ['time.uptime'], 
    data: function (track, ctx) {
        track.send(200, '<div>Server uptime: ' + ctx.res.time.uptime + 'ms</div>');
    }
});

fist.route('GET /', 'index');

fist.listen(1337);
```
 * [Приложение](#%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)
 * [Плагин](#%D0%9F%D0%BB%D0%B0%D0%B3%D0%B8%D0%BD)
 * [Узел](#%D0%A3%D0%B7%D0%B5%D0%BB)
 * [Трэк](#%D0%A2%D1%80%D1%8D%D0%BA)
 * [Роутер](#%D0%A0%D0%BE%D1%83%D1%82%D0%B5%D1%80)

#Приложение
Приложением называется экземпляр класса [```Framework```](Framework.js).
Класс [```Framework```](Framework.js) наследует от ```EventEmitter```, таким образом приложение во время своей работы может сообщать среде о каких либо действиях.
##События
###```sys:ready()```
Приложение проинициализировано и готово отвечать на запросы
###```sys:error(*)```
Критическая ошибка инициализации приложения, оно никогда не подожжет событие ```sys:ready```, то есть никогда не начнет отвечать на запросы. В обработчике есть смысл только прологгировать фатальное исключение и завершить процесс с соответствующим кодом выхода. Но если вы можете разрешить ошибку, то после того как она будет разрешена, сами подожгите [```sys:ready```](#sysready) и сервер начнет отвечать на запросы
###```sys:request(Track)```
В приложение поступил запрос
###```sys:response(Track)```
Приложение выполнило ответ
###```sys:match(Track)```
[Роутер](#%D0%A0%D0%BE%D1%83%D1%82%D0%B5%D1%80) нашел подходящий под ```url``` маршрут
###```sys:ematch(Track)```
[Роутер](#%D0%A0%D0%BE%D1%83%D1%82%D0%B5%D1%80) не смог найти подходящего маршрута
###```ctx:accept(Object)```
[Узел](#%D0%A3%D0%B7%D0%B5%D0%BB) разрешен без ошибки.
В обработчик события передается объект c тремя полями:

```event.path``` - имя узла

```event.time``` - время разрешения узла

```event.data``` - данные с которыми узел был разрешен

###```ctx:reject(Object)```
[Узел](#%D0%A3%D0%B7%D0%B5%D0%BB) разрешен с ошибкой.
В слушатель события передается такой же объект как и в [```ctx:accept```](#ctxaccept)
###```ctx:notify(Object)```
[Узел](#%D0%A3%D0%B7%D0%B5%D0%BB) передал сообщение.
В слушатель события передается такой же объект как и в [```sys:accept```](#ctxaccept)
##API
###```new Framework([params])```
Создает экземпляр приложения.
```js
var Framework = require('fist/Framework');
var app = new Framework();
```
В конструктор можно передать объект параметров, который будет склонирован в объект [app.params](#appparams)
###```app.params```
Объект параметров приложения, переданных при инстанцировании. Может использоваться в [плагинах](#%D0%9F%D0%BB%D0%B0%D0%B3%D0%B8%D0%BD) и [узлах](#%D0%A3%D0%B7%D0%B5%D0%BB).
###```app.unit(unit)```
Метод, декларирует [узел](#%D0%A3%D0%B7%D0%B5%D0%BB).

```unit.path``` - уникальное имя узла, если продекларировать еще один [узел](#%D0%A3%D0%B7%D0%B5%D0%BB) с такми же ```path```, то последняя декларация "затрет" предыдущую.

```unit.deps``` - завсисимости [узла](#%D0%A3%D0%B7%D0%B5%D0%BB). Это может быть как массив строк, имен [узлов](##%D0%A3%D0%B7%D0%B5%D0%BB), так и просто строка, если у [узла](#%D0%A3%D0%B7%D0%B5%D0%BB) только одна зависимость. Необязательный аргумент.

```unit.data``` - тело [узла](#%D0%A3%D0%B7%D0%B5%D0%BB), может быть любого типа, а поэтому необязательный аргумент.

```unit.base``` - базовый узел, от которого должен унаследовать текущий. Или строка - имя базового узла, или констроктор базового узла (имеет смысл при наследовании от узлов, которые не продекларированы в приложении).

```js
app.unit({path: 'answer', data: 42});
```
###```app.route(pattern, data)```
Декларирует маршрут во встроенном [роутере](#%D0%A0%D0%BE%D1%83%D1%82%D0%B5%D1%80) приложения, связывая его с [узлом](#%D0%A3%D0%B7%D0%B5%D0%BB).

```pattern``` - шаблон урла запроса в терминах [роутера](#%D0%A0%D0%BE%D1%83%D1%82%D0%B5%D1%80)

```data``` - статические данные, связанные с маршрутом. ```data``` может содержать поле ```name``` чтобы дать маршруту имя, по которому в дальнейшем можно будет обраться к нему. Также необходимо указать с каким узлом будет свзяан маршрут. По умолчанию ```data.unit``` равно ```data.name``` Если нужно связать с маршрутом [узел](#%D0%A3%D0%B7%D0%B5%D0%BB) имя которого отличное от ```name``` маршрута, то можно указать это в ```data.unit```.
```js
app.route('GET /', {name: 'index', unit: 'customUnit'});
```
Остальные опции маршрутов роутера можно посмотреть в разделе про [роутер](#%D0%A0%D0%BE%D1%83%D1%82%D0%B5%D1%80).
```js
app.route('GET', '/static/', 'static-files', 'static', {
    noend: true,
    nocase: true
});
```
###```app.plug([plugin[, plugin...]])```
Добавляет в приложение плагин, который будет выполнен при инициализации.
```js
app.plug(function (done) {
    this.myFeature = 42;
    done();
});
```
###```app.ready()```
Запускает инициализацию приложения. Во время инициализации выполняются все плагины и по ее завершении зажигается событие [```sys:ready```](#sysready), если хотя бы один из плагинов разрешился с ошибкой, то [```sys:ready```](#sysready) никогда не будет зажжено, но будет зажжено [```sys:error```](#syserror)
###```app.listen()```
Запускает сервер приложения и автоматом вызывает [```app.ready```](#appready)
#Плагин
Плагинами для [приложения](#%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5) называются задачи, которые следует выполнить до того как [приложение](#%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5) начнет отвечать на запросы. Плагин представляет собой функцию, в которую передается резолвер. Плагин должен вызвать резолвер чтобы объявить о завершении своей работы.
```js
//  подключаю плагин для инициализации шаблонов
app.plug(function (done) {
    var self = this;
    Fs.readDir('views', function (list) {
        list.forEach(function (item) {
            this.renderers[item] = require('./views/' + item);
        }, self);
        done();
    });
});
```
Плагины начинают отрабатывать при инициализации. Чтобы запустить инициализацию, необходимо вызвать [```app.ready()```](#appready)
#Узел
Узлом называется минимальная минимальная функциональная часть [приложения](#%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5).
Если у [приложения](#%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5) потребовали разрешить узел, то сначала разрешаются зависимости узла, а затем сам узел. Разрешением узла называется разрешение контекста его вызова. Узел может быть разрешен как с результатом так и с ошибкой. Узел декларируется методом [```app.unit```](#appunit).
Тело узла может быть как функционального типа, так и ```promise```.
Если тело узла явзяется функией, то в него передается два аргумента, [```track```](#%D0%A2%D1%80%D1%8D%D0%BA) и ```ctx```. Второй аргумент является контекстом вызова узла, который содержит в себе результаты выполнения зависимостей в объектах ```ctx.ers``` и ```ctx.res```. Контекст вызова узла является потомком класса ```[vow](https://github.com/dfilatov/vow).Deferred```. Если из узла возвратить ```promise```, не связанный с этим deferred, то второй будет разрешен возвращенным значением.

```js
app.unit({
    path: 'awesome',
    data: function (track, ctx) {
        asker('http://example.com/asom-api', ctx.getResolver());
    
        return ctx.promise();
    }
});

//  или 
app.unit({
    path: 'awesome',
    data: function (track) {
        
        return vowAsker('http://example.com/asom-api');
    }
})
```
Разрешение узла влечет за собой триггер события [```ctx:accept```](#ctxacceptobject) или [```ctx:reject```](#sysrejectobject). Функцию можно вызывать как непосредственно так и через свойства-методы ```done.accept([*])```, ```done.reject([*])```. Также есть метод ```done.notify([*])```, который не разрешает узел но поджигает событие [```sys:notify```](#sysnotifyobject)

Функцию ```done``` вызывать не обязательно, вы можете разрешать узел другими способами. Например если вы вернете из узла любое значение, отличное от ```undefined``` до того как вызовете ```done```, то вызов ```done``` ожидаться не будет. ```Fist``` будет разрешать именно возвращенное значение.
```js
app.unit({
    path: 'version', 
    data: function () {

        return require('./package.json').version;
    }
});
```
В примере выше возвращается примитив, примитив не может разрешить узел с ошибкой, значит узел будет разрешен без ошибки с возвращенным результатом.

##Зависимости узлов
Если узел имеет зависимости, то в контексте вызова узла можно обнаружить результаты их выполнения.
```js
app.unit({
    path: 'accept', 
    data: function () {
    
        throw 'ERR';
    }
});

app.unit({
    path: 'reject', 
    data: function () {
        return 'RES';
    }
});

app.unit({
    path: 'assert', 
    deps: ['reject', 'accept'], 
    data: function (track, ctx) {
        assert(ctx.ers.reject === 'ERR');
        assert(ctx.res.accept === 'RES');
    
        return 'OK';
    }
});
```
Тут все просто и почти никакой магии. Есть одна особенность имен узлов. Имена узлов могут интерпретироваться как ```namespace```
```js
app.unit({
    path: 'meta.data', 
    data: 42
});
app.unit({
    path: 'assert', 
    deps: ['meta.data'], 
    data: function (track, ctx) {
        assert(ctx.res.meda.data.data === 42);
        
        return 'OK';
    }
});
```
Если по какой-то причине вы не хотите чтобы точки интерпретировались как особые символы в именах узлов, то вы можете их экранировать
```js
app.unit({
    path: 'meta\\.data', 
    data: 42
});

app.decl({
    data: 'assert', 
    deps: ['meta\\.data'], 
    data: function (track, errors, result, done) {
        assert(result['meta.data'] === 42);
    
        return 'OK';
    }
});
```
#Трэк
Итак, ```track```. Это специальный объект который передается в функциональное тело каждого [узла](#%D0%A3%D0%B7%D0%B5%D0%BB), участвующего в операции разрешения. Этот объект нужен для обработки запроса и управления операцией разрешения [узла](#%D0%A3%D0%B7%D0%B5%D0%BB). Другим словом с помощью ```track``` можно читать из ```request```, писать в ```response```  и вызывать другие [узлы](#%D0%A3%D0%B7%D0%B5%D0%BB).
##API
###```track.agent```
Ссылка на [приложение](#%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5), может использоваться для триггера кастомных событий.
###```track.url```
Разобранный ```url``` запроса.
###```track.match```
Результат матчинга [роутера](#%D0%A0%D0%BE%D1%83%D1%82%D0%B5%D1%80), объект с ключами, именами параметров с их значениями.
###```track.route```
```name``` маршрута, с которому бы привязан узел, который запустил реакцию резрешения.
###```track.arg(name[, only])```
Возвращает значение аргумента запроса. По умолчанию смотрит есть ли значние в [```track.match```](#trackmatch), а если там его нет то смотрит в [```track.url```](#trackurl).query. Если передать вторым аргументом ```true```, то будет искать значение только в [```track.match```](#trackmatch).
###```track.header([name[, value[, soft]]])```
Полиморфный метод, с помощью которого можно читать заголовки из ```request``` и ставить заголовоки в ```response```.
Если вызвать метод без аргументов, то он вернет все заголовки запроса объектом. Если передать один аргумент, то будет возвращено значение одного заголовка с переданным именем. Если передать два аргумента, то метод установит заголовок в ```response```. Для установки заголовков есть еще третий аргумент, который устанавливает soft-режим установки заголовка. Если он будет позитивным, то заголовок установится только если он еще не был установлен. Иначе заголовок будет затирать собой уже установленный. Можно передать первым и единственным аргументом объект, тогда будут установлены все заголовки, имена которых будут соответствовать ключам, а значения - значениям переданных объектов по их ключам. Также можно передать вторым аргуметом ```soft```, который будет применен ко всем устанавливаемым заголовкам.
###```track.cookie([name[, value[, opts]]])```
Метод похож по своей полиморфности на [```track.header```](#trackheader) лишь за тем исключением, что нет soft-режима и нельзя ставить куки пачкой. Если вызвать метод без аргументов, то будут возвращены все куки запроса, а именно, разобранный заголовок запроса ```Cookie```. Если вызвать метод с одним аргументом, то будет возвращено значение конкретной куки запрсоа. Если вызвать метод с двумя и более оргументами, то будет установлены куки в ```response```. По факту - это шортхэнд для установки заголовка ```Set-Cookie```. Первым аргументом передаем имя устанавливаемой куки, вторым значение, третьим можно передать опции установки куки.

```opts.expires``` - полиморфный параметр. Если его тип - ```Number```, то он будет работать как ```max-age```, только в миллисекундах, иначе переданное значение будет приведено к ```Date```, и эта дата будет являться датой истекания срока жизни куки.

```opts.path``` - документ на который надо ставит куку

```opts.secure``` - если значение позитивное, то будет добавлен атрибут ```secure```

```opts.httpOnly``` - если значение позитивное, то будет поставлен атрибут ```httponly```

```opts.domain``` - домен на который будет поставлена кука
###```track.body(done)```
Получает тело запроса если оно есть. Метод по заголовку запроса ```Content-Type``` понимает как закодировано тело и парсит его соответствующим образом. Поддерживаются тела ```multipart```, ```urlencoded```, ```json```. В других случаях тело будет возвращено в формате ```raw```. То есть сырой буфер данных. В любом случае, если при парсинге не произошло ошибки, результат выглядит как объект с ключом ```type```, который указывает на тип тела, и ключом ```input``` в которым по ключам содержатся отправленные данные. Если тело было в формате ```multipart```, то в результирующем объекте будет еще ключ ```files``` в объекте которого будут ключи - имена полей через которые были отправлены файлы, а каждый файл - это объект c тремя полями: ```name```, ```mime```, ```data```.

```name``` - имя файла

```mime``` - ```Content-Type``` part-а в котором был отправлен файл.

```data``` - содержимое файла в виде буффера данных

Этот метод можно вызывать сколько угодно раз, тело будет разобрано в любом случае один раз.
###```track.status([statusCode])```
Полиморфный метод. Если вызвать без аргументов, то вернет ```statusCode``` ответа, который был установлен. Если передать аргумент то будет установлен ```statusCode```
###```track.sent()```
Проверяет, было ли отправлено тело ответа.
###```track.send([code, [body]])```
Метод, который выполняет ответ [приложения](#%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5) и останавливает реакцию разрешения узла.
Обязательных аргументов нет. Первым аргументом можно передать ```statusCode``` ответа. Вторым или единственным аргументом можно передать тело ответа. ```send``` различает несколько типов тел ответа и умеет автоматически устанавливать ```Content-Type``` и ```Content-Length``` если они еще не были установлены.
Во первых строки, если в виде тела была передана строка, то ```send``` автоматически поставит ```Content-Type: text/plain``` если вы не выставили сами этот заголовок.
Также ```send``` понимает ```Buffer``` и ```Readable```-потоки. Если не был выставлен ```Content-Type```, то ```send``` подумает что это абстрактный бинарник и поставит ```Content-Type: application/octet-stream```. ```send``` особенным образом относится к объектам класса ```Error```. Если вы НЕ запустили приложение с параметром ```staging: true```, то если вы будете передавать в ```send``` объекты ошибок со statusCode >= 500, то клиенту будет отправлен ```stack-trace```, иначе вместо ```stack-trace``` будет отправлено стандартное http-сообщение, соответствующее ```statusCode```. Также ```send``` заботится о том чтобы не было отправлено тело в ответах на ```HEAD```-запросы, или если вы установили специфический ```statusCode```, который не предполагает наличие тела. Например ```304``` (Not Modified), в таком случае ```send``` еще позаботится о том, чтобы на клиент не ушли ```content-*``` заголовки.
###```track.invoke(name)```
Запускает операцию разрешения на [узле](#%D0%A3%D0%B7%D0%B5%D0%BB) по его имени. Возвращает ```promise```.
###```track.buildPath(name[, params])```
Создает ```url``` страницы [приложения](#%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5) по ```name``` маршрута из ```expr```, указанном при декларации маршрута. Вторым аргументом передаются параметры для ```url```. Часть параметров попадет в ```path``` ```url```-a, в зависимости от того какой ```expr```, а остальные попадут в ```query```.
###```track.goToPath(name[, params])```
Перенаправляет на ```url```, по созданный из ```params``` по ```expr``` маршрута, соответствующего ```name```
###```track.render([code, ]name[, arg[, arg...]])```
Шаблонизирует данные с помощью шаблона ```name``` и отправляет их с переданным ```statusCode```, который по-умолчанию равен ```200```. Все остальные аргументы будут переданы в функцию-шаблонизатор, которая будет вызвана в контексте ```track```. Функции-шаблонизаторы должны находиться в объекте ```app.renderers```.
###```track.redirect([code, ]url)```
Позволяет выполнить редирект на клиенте. Просто шортхэнд для установки заголовка ```Location``` со значением ```url``` и правильного ```statusCode```. По-умолчанию ```statusCode``` ставится ```302```, но вы можете передать первым аргументом любой код редиректа. Метод проконтролирует, чтобы вы не ошиблись и позволит передать только один из семантических статус-кодов, предназанченных специально для перенаправления. Также метод формирует тело ответа, по умолчанию просто равное экранированному ```url```, но если вы поставите ```Content-Type: text/html```, то ```redirect``` сверстает гиперссылку &lt;a href="{url}"&gt;{url}&lt;/a&gt;

#Роутер
Документация по [роутеру](https://github.com/golyshevd/finger)
